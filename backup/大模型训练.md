
## 提高推理能力方法
<details><summary>Details</summary>
<p>

哪些提高推理能力的方法
提高推理能力需要从数据、训练方法、模型架构和推理策略等多个层面入手。

一、 数据层面（吃什么补什么）
高质量推理数据构建：

合成数据：利用更强的模型（如GPT-4）生成大量带有详细推理步骤（CoT） 的高质量问答对。

数据清洗：过滤掉低质量、含有错误推理步骤的数据。

数据混合比例优化：

在预训练或SFT（监督微调）阶段，适当提高代码、数学、逻辑谜题等推理密集型数据的比例。代码本质上是逻辑的具象化，对推理能力提升极大。

二、 训练方法层面（怎么学）
思维链微调（CoT Fine-Tuning）：

不仅教模型“答案是什么”，更重要的是教它“如何一步步得到答案”。使用带有推理过程的数据进行监督微调。

强化学习（RLHF/RLAIF）：

奖励模型（Reward Model）：不仅奖励最终答案正确，还要奖励推理过程合理、清晰、正确。

通过PPO等算法，基于奖励模型的反馈优化模型策略，使其更倾向于产生正确的推理路径。

过程监督（Process Supervision）：

比结果监督更极致的做法。为推理过程中的每一步都提供正确与否的标签或奖励。

模型在学习过程中会获得更密集、更准确的反馈，能有效避免“一路错到底”的情况。

三、 推理策略层面（怎么用）
自洽性（Self-Consistency）：

对于同一个问题，让模型多次采样生成多个不同的推理路径和答案。

然后通过投票（Majority Voting） 的方式选择最一致的答案。这能有效纠正单次推理中可能出现的随机错误。

思维树（Tree of Thoughts, ToT）：

让模型在推理时同时探索多种可能的推理步骤，像在树结构中一样进行广度或深度搜索。

每一步都进行评估和剪枝，保留最有希望的路径。这种方法将LLM本身作为一个“推理引擎”。

引导式推理（Prompting Engineering）：

Chain-of-Thought (CoT)：最简单的提示，只需在提示中加入“Let's think step by step”。

Least-to-Most：提示模型先将复杂问题分解成子问题，逐个解决后再整合。

Step-Back Prompting：让模型先从问题中抽象出更一般的概念或原则，再应用这些原则来解决问题。

</p>
</details> 

## 强化学习中一些基本概念：

**人类反馈强化学习(Reinforcement Learning from Human Feedback, RLHF)**：
核心思想:让LLM的输出能够符合人类偏好(即人类反馈),主要通过人类偏好数据集(例如针对一个response,会
有人类手工标注对其打分)训练一个奖励模型,通过奖励模型计算奖励,以此来判断LLM的输出是否符合人类偏好。

早期的RLHF主要涉及到四个模型:
Actor:主模型,即需要更新的策略模型,负责输入prompt,输出token
Ref(reference model) 微调前的模型,负责防止actor模型在更新过程中偏离原模型过大
RM(reward model): 奖励模型,提前训练好的模型,负责为actor的输出打分,主要目标为是否符合人类偏好
Critic (也叫value model):评估模型,负责根据状态来估计按照当前策略进行能够带来多少期望回报,进而计算优势,优势用于更新actor模型,而critic本身也会更新,更新目标是更准确地估计期望回报。
备注：
ref模型，和rm模型都是不会更新，更新的只有critic模型，ref模型（主要防止偏离），现在考虑去掉，因为大模型能力变强

**KL散度（Kullback–Leibler Divergence）公式：**
用于衡量两个概率分布P和Q之间的差异。
离散分布： $D_{KL}(P \parallel Q) = \sum_{i} P(i) \log \frac{P(i)}{Q(i)}$
连续分布： $D_{KL}(P \parallel Q) = \int_{-\infty}^{\infty} p(x) \log \frac{p(x)}{q(x)} dx$
为什么在RLHF中使用KL散度？
在RLHF中，KL散度被用作奖励函数的一部分：
$R_{\text{total}} = R_{\text{Human}}(x, y) - \beta D_{KL}(\pi_\theta(y|x) \parallel \pi_{\text{SFT}}(y|x))$ 
KL散度惩罚项强制新策略 $\pi_\theta$ 的输出分布不要偏离原始的SFT模型 $\pi_{\text{SFT}}$ 太远。

**熵 (Entropy)**： 对于一个概率分布，熵越高，表示分布越均匀，随机性越大，越不确定；熵越低，表示分布越集中（某个行动概率接近1）。
公式: 对于离散策略 π(a|s)，其熵 H 的计算公式为：H(π(·|s)) = -Σ π(a|s) * log π(a|s)
在RL中的作用:
鼓励探索: 在损失函数中加入熵奖励 (Entropy Bonus)，即 +β * H(π(·|s))，可以鼓励策略保持一定的随机性，防止其过早地收敛到一个局部最优的确定性策略，从而探索更多可能的行为。

平衡方法:
ε-贪婪 (ε-Greedy): 以 (1-ε) 的概率选择当前最优行动（利用），以 ε 的概率随机选择行动（探索）。
上置信界算法 (UCB): 为每个行动的期望奖励增加一个不确定性bonus，优先选择期望奖励高或不确定性大的行动。
基于策略的方法 (Policy-based Methods): 直接学习一个随机策略（如输出行动的概率分布），策略本身的随机性就天然地提供了探索。熵是衡量这种随机性的关键指标

**优势函数** (Advantage Function) A(s, a) = Q(s, a) - V(s)：
使用优势函数而不是纯奖励Q，可以降低方差，使学习更稳定。
常见的改进方法：
1. GAE (Generalized Advantage Estimation)： 这是最常用的方法。GAE通过引入一个权衡偏差和方差的参数 $\lambda$，综合了k步TD误差的优势估计，使得估计更加平滑可靠。
2. Value Function优化： 一个训练良好的价值函数（Critic）是准确估计Advantage的基础。确保价值函数有足够的容量和训练步数。
3. Normalization： 对一个batch内的Advantage进行归一化（减去均值，除以标准差），可以稳定策略的更新。
4. Clipping Advantages： 类似价值损失，也可以对Advantage进行裁剪，防止极端值的影响。

**Lora**：核心是低秩适应，通过引入少量可训练参数高效微调模型；
**QLoRA**：在LoRA的基础上，通过对预训练模型进行量化压缩，显著降低了微调对显存的需求

### Reward奖励获取方式分别是什么
1. 人工标注（Human Annotation） 优点是符合人类偏好，缺点是成本高
2. 模型基于规则/启发式生成（Rule-based/Heuristic Reward）
3. 奖励模型（Reward Model - RM） 首先用1人工标注训练一个单独的奖励模型
4. 对抗训练（Adversarial Training）训练一个判别器

## LLM中损失函数
LLM的损失函数是标准的交叉熵损失（Cross-Entropy Loss），具体是语言建模损失。

对于一个样本（序列 $x_1, x_2, ..., x_T$），损失函数为：
$L = -\frac{1}{T} \sum_{t=1}^{T} \log P(x_t | x_{<t})$
其中 $P(x_t | x_{<t})$ 是模型在给定上文 $x_{<t}$ 的条件下，预测下一个词是 $x_t$ 的概率

交叉熵损失计算为：
$L_t = -\sum_{i=1}^{V} y_i \log(p_i) = -\log(p_{x_t})$
因为只有 $y_{x_t}=1$，其他 $y_i=0$。
所以，对于这一个token的损失就是其负对数概率。整个序列的损失是所有token损失的平均。
举例：如果模型对某个目标词预测的概率是 0.01，那么该token的损失就是 -log(0.01) ≈ 4.605。如果模型非常确信（概率为 0.99），损失就是 -log(0.99) ≈ 0.01。

## 强化学习中用到算法：
**PPO原理**：
核心思想: 在更新策略时，避免步长太长（更新幅度太大）导致策略崩溃（性能急剧下降）
$L^{CLIP}(\theta) = \hat{\mathbb{E}}_t [\min(r_t(\theta) \hat{A}_t, \text{clip}(r_t(\theta), 1-\epsilon, 1+\epsilon) \hat{A}_t)]$

其中：
- $\theta$： 策略参数。
- $r_t(\theta) = \frac{\pi_\theta(a_t | s_t)}{\pi_{\theta_{\text{old}}}(a_t | s_t)}$： 新策略与旧策略的概率比。
- $\hat{A}_t$： 时间步t的优势函数估计（表示某个动作比平均动作好多少）。
- $\epsilon$： 超参数（如0.2），限制更新幅度。

关键机制:
比率 (Ratio): r(θ) = π_θ(a|s) / π_θ_old(a|s)。新策略概率除以旧策略概率。
稳定性：因为_直接用sft后的模型会非常不稳定_。裁剪 (Clipping)就是为了稳定性。PPO的损失函数会裁剪这个比率，将其限制在区间 [1 - ε, 1 + ε] 内（ε是一个小超参数，如0.1或0.2）。这确保了每次更新都是“小幅且安全的”。
目标函数: L = min( r(θ) * A, clip(r(θ), 1-ε, 1+ε) * A )。其中A是优势函数。通过取最小值，算法忽略了那些会导致策略发生巨大变化且对性能有负面影响的更新。
性能： 相比于传统的策略梯度方法（如TRPO，虽然理论严谨但计算复杂），PPO用这种简单的裁剪机制达到了相当甚至更好的性能，同时实现更简单、计算更高效。

**GRPO (Group Relative Policy Optimization)**
核心思想: 在有多个人类标注者偏好（可能存在分歧）的场景下，不学习一个单一的奖励模型，而是学习一个奖励模型组。

原理: 训练多个奖励模型 {RM_i}，每个代表不同的人类偏好子群体。在RL优化时，策略的更新要考虑到整个模型组的共识，而不是单个模型。例如，目标函数可能是最小化策略相对于所有奖励模型的最差情况性能（类似于鲁棒优化），或者是根据模型组的平均奖励进行优化。这提高了策略的鲁棒性和公平性。

**DAPO (Distributional Advantage Policy Optimization)**
核心思想: 标准PPO使用优势函数的点估计（一个值），DAPO则使用优势函数的完整分布。

原理: 它建模优势函数的不确定性。通过考虑优势的分布，智能体可以更智能地平衡探索与利用：对于那些优势估计不确定性很高的行动，即使其均值略低，也可能值得探索。这可以带来更稳定、更高效的学习。

**VAPO (Value-Augmented Policy Optimization)**

原理 : 可能通过增加价值函数损失的权重，或使用价值函数来更好地估计优势，以减少方差，提升PPO的稳定性。

### 训练框架
verl框架：verl 是一个专为大语言模型（LLM） 设计的强化学习（RL）训练框架

核心创新：HybridFlow 与 3D-HybridEngine
verl 的核心是其 HybridFlow 架构和 3D-HybridEngine。

HybridFlow 通过混合编程模型解耦了RLHF训练中的控制流（高层逻辑，如多个模型角色的交互）和计算流（底层执行，如单个模型的前向/反向传播）。这使得算法工程师可以更专注于高层逻辑的设计，而无需过度纠缠于底层的分布式执行细节。


**工作流程（以PPO为例）：**
一个典型的RL训练循环（例如PPO）在verl中大致包含以下步骤：
生成 (Generation): Actor模型 接收一批提示词（prompts），生成回应（responses）。
准备 (Preparation): 生成的回应会交由Critic模型（评估状态价值）、奖励模型(RM)（计算即时奖励）和参考模型(Reference Model)（计算与初始模型的KL散度，防止策略偏离太远）进行评估。
训练 (Training): 利用步骤2中计算出的优势函数和损失，更新Actor和Critic模型的参数。


一些训练中可能遇到问题：
8. 为什么你要用GRPO？GPRO结果比之前好多少？显存开销多大？训练一个Step需要多久？奖励函数如何设置的，为什么？有没有想过为什么一开始Reward出现大幅度震荡？GRPO是否一定有效，还有什么解决方法？
9. Post-Training 的工作机制，为什么要做三阶段训练？什么情况下应该用GRPO？为什么DeepSeek用了GRPO？如何从V3到R1？
10. 微调是如何进行微调的？为什么LoRA能够work？除了LoRA外，还了解哪些微调方法？
11. 后训练用的哪个框架？你用过什么框架？如何使用deepspeed进行分布式训练？脚本是你自己写的吗？
12. 知道什么Linux命令？
13. 用过C++，Java吗？平时用什么多?
14. 如何去评价你工作的产出和质量（基本上每个面试官都会问）
15. FLUX的工作原理，LoRA在这个地方起到了什么作用？
链接：https://www.nowcoder.com/feed/main/detail/cb3c1bff8b9d40f0a5431b26ebcc6042?sourceSSR=search


## 微调的全链路

1. 问题定义与数据准备： 明确任务（如文本分类、NER、对话生成）。收集和清洗数据，构建(instruction, input, output)格式的样本。
2. 模型选型与基座模型选择： 根据任务和资源选择模型架构（如LLaMA, ChatGLM, BERT）。选择合适的预训练模型作为起点。
3. 微调方法选择：
  - 全参数微调： 资源充足时使用，更新所有参数。
  - 参数高效微调（PEFT）： 当前主流。如LoRA（在原始权重旁增加低秩适配器，只训练适配器）、Adapter、Prompt Tuning等。务必详细解释LoRA的原理和优势。
4. 训练配置： 设置超参数（学习率、batch size、训练轮次）。使用DeepSpeed/FSDP进行分布式训练（如果问得深）。
5. 训练与监控： 启动训练，使用Tensorboard/W&B等工具监控Loss、评估指标变化，防止过拟合。
6. 评估与验证： 在预留的验证集和测试集上评估模型性能，对比微调前后的效果。
7. 模型部署与应用： 将微调后的模型（如果是LoRA，需与基座模型合并）转换为可用于推理的格式（如Hugging Face pipelines），并集成到应用中去。
